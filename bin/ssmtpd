#!/usr/bin/env jit.go

/** 
ssmtpd: This code is based on Go-Guerrilla SMTPd Version 1.1, but heavily
modified towards the needs of the kinko.me email crypto package. 
Find Go-Guerrilla's License statement below.

Changes:

- An email will no longer be put into a redis database, but instead be 
  passed on to a filter program. Depending on that filter's return value
  the email will be accepted or rejected.
- No nginx integration
- No configuration file - all configuration is passed on via command line.
- Users are authenticated against the accounts.db sqlite3 database.

To run install the jit package from github.com/radiospiel/jit.

*/

/** 
Go-Guerrilla SMTPd
A minimalist SMTP server written in Go, made for receiving large volumes of mail.
Works either as a stand-alone or in conjunction with Nginx SMTP proxy.
TO DO: add http server for nginx

Copyright (c) 2012 Flashmob, GuerrillaMail.com

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"encoding/base64"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os/exec"
	"log"
	"net"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

const GSMTP_MAX_SIZE	=  20971520	 // The maximum size of an email
var GSMTP_HOST_NAME		=  "server.example.com" // hostname for (HELO,EHLO)
const GSMTP_TIMEOUT		=	100		 // how many seconds before timeout.
const GM_MAX_CLIENTS	=	500		 // max number of clients
var GSTMP_AUTHENTICATE	=	 ""		 // command to authenticate
var GSTMP_PROCESS		=	 ""		 // command to process email
var GSMTP_PUB_KEY		=	 ""		 // TLS certificate
var GSMTP_PRV_KEY		=	 ""		 // TLS key
var GSMTP_VERBOSE		=	false	 // verbose operation?
var GSMTP_TLS_OPTIONAL	=   false	 // TLS optional?

/*
 * internal global values
 */

var gstmp_listen_interface string		   // interface to listen to.
var gstmp_tls_config *tls.Config		   // tls configuration.
var gstmp_timeout time.Duration			   // timeout.
var gstmp_sem chan int					   // currently active clients.
var gstmp_save_mail_chan chan *Client	   // workers for processing mail.

/* -- a client ------------------------------------------------------------- */

type Client struct {
	clientId	int64			// id of client connection.
	helo		string			// helo as sent from client
	tls_on		bool			// set after switched to TLS
	username	string			// username after successful authentication
	mail_from	string			// FROM via SMTP protocol
	rcpt_to		string			// RCPT via SMTP protocol
	data		string			// mail data
	log			func(int, string) 	// log info
	conn		net.Conn
	bufin		*bufio.Reader
	bufout		*bufio.Writer
	processMessage string		// result message of email processing
	processStatus chan bool
}

const fatal = 0
const fail = 1
const warn = 2
const info = 3 

func Log(level int, s string) {
	switch level {
		case fatal: 		log.Fatalf(s);
		case fail, warn:	log.Println(s);
		default: 			if GSMTP_VERBOSE { log.Println(s); }
	}
}

func parseArguments() {
	log.SetOutput(os.Stderr)

	// -- parse command line arguments ----------------------------------------

	var port string

	flag.StringVar(&port,				"port",			"2525",					"port to listen on, eg. 2525")
	flag.StringVar(&GSMTP_PRV_KEY,		"ssl-key",		"",						"The SSL key")
	flag.StringVar(&GSMTP_PUB_KEY,		"ssl-cert",		"",						"The SSL cert")
	flag.StringVar(&GSTMP_AUTHENTICATE, "auth",			"",						"authenticate command")
	flag.StringVar(&GSTMP_PROCESS,		"process",		"",						"process command")
	flag.StringVar(&GSMTP_HOST_NAME,	"hostname",		"server.example.com",	"The STMP hostname")
	flag.BoolVar(&GSMTP_VERBOSE,		"verbose",		false,					"verbose operation")
	flag.BoolVar(&GSMTP_TLS_OPTIONAL, 	"tls-optional", false,					"TLS optional?")
	flag.Parse()

	// -- initialize internal data

	gstmp_listen_interface = "0.0.0.0:" + port

	gstmp_sem = make(chan int, GM_MAX_CLIENTS)
	gstmp_save_mail_chan = make(chan *Client, 5)
	gstmp_timeout = time.Duration(GSMTP_TIMEOUT) * time.Second

	if GSMTP_PUB_KEY == "" || GSMTP_PRV_KEY == "" {
		Log(fatal, "Missing -ssl-key or -ssl-cert arguments")
	}
}

func main() {
	parseArguments()

	cert, err := tls.LoadX509KeyPair(GSMTP_PUB_KEY, GSMTP_PRV_KEY)
	if err != nil {
		Log(fatal, fmt.Sprintf("There was a problem with loading the certificate: %s", err))
	}
	gstmp_tls_config = &tls.Config{Certificates: []tls.Certificate{cert}, 
								ClientAuth: tls.VerifyClientCertIfGiven, 
								ServerName: GSMTP_HOST_NAME}

	// Start listening for SMTP connections
	listener, err := net.Listen("tcp", gstmp_listen_interface)
	if err != nil {
		Log(fatal, fmt.Sprintf("Cannot listen on port, %v", err))
	} else {
		Log(warn, fmt.Sprintf("Listening on tcp %s", gstmp_listen_interface))
	}

	var clientId int64 = 1
	for {
		conn, err := listener.Accept()
		if err != nil {
			Log(warn, fmt.Sprintf("Accept error: %s", err))
			continue
		}
		Log(info, "Currently " +strconv.Itoa(runtime.NumGoroutine())+ " serving goroutines")
		gstmp_sem <- 1 // Wait for active queue to drain.
		go handleClient(&Client{
			conn:			conn,
			bufin:		 	bufio.NewReader(conn),
			bufout:		 	bufio.NewWriter(conn),
			clientId:	 	clientId,
			processStatus:	make(chan bool),
		})
		clientId++
	}
}

/*
 * parse SMTP commands.
 */

const HELO			= "HELO"
const EHLO			= "EHLO"
const NOOP			= "NOOP"
const RSET			= "RSET"
const AUTH_PLAIN	= "AUTH PLAIN " // note space at end!
const AUTH_LOGIN	= "AUTH LOGIN"
const MAIL_FROM		= "MAIL FROM:"
const RCPT_TO		= "RCPT TO:"
const DATA			= "DATA"
const STARTTLS		= "STARTTLS"
const QUIT			= "QUIT"

func parseSmtpCommand(input string) (cmd string, remainder string) {
	upcase := strings.ToUpper(input)

	commands := []string{
		HELO, EHLO, NOOP, RSET, STARTTLS, QUIT,
		AUTH_PLAIN, AUTH_LOGIN,
		MAIL_FROM, RCPT_TO,
		DATA}

	for _, cmd := range commands {
		if strings.Index(upcase, cmd) == 0 {
			remainder = input[len(cmd):]
			return cmd, remainder
		}
	}

	return "", ""
}

func handleClient(client *Client) {
	remote_addr, _, _ := net.SplitHostPort(client.conn.RemoteAddr().String())

	// client logging
	client.log = func(level int, msg string) {
		if client.mail_from != "" && client.rcpt_to != "" {
			mail_from := strings.Trim(client.mail_from, "<>")
			rcpt_to := strings.Trim(client.rcpt_to, "<>")

			msg = fmt.Sprintf("%s -> %s: %s", mail_from, rcpt_to, msg)
		}
		if level == fail {
			msg = fmt.Sprintf("FAIL: %s", msg)
		}
		if client.username == "" {
			msg = fmt.Sprintf("#%d: %s", client.clientId, msg)
		} else {
			msg = fmt.Sprintf("#%d (%s): %s", client.clientId, client.username, msg)
		}
		Log(level, msg)
	}
	
	client.log(info, fmt.Sprintf("Connected from %s", remote_addr))

	defer func() {
		client.conn.Close()
		<-gstmp_sem // Done; enable next client to run.
	}()

	defer func() {
		err := recover()
		switch {
		case err == nil:
			;
		case err == io.EOF:
			client.log(warn, fmt.Sprintf("Client closed connection: %v", err))
		default:
			neterr, ok := err.(net.Error);
			if ok && neterr.Timeout() {
				client.log(warn, fmt.Sprintf("Client timed out: %v", err))
			} else {
				client.log(warn, fmt.Sprintf("Client IO error: %v", err))
			}
		}
	}()

	/*
	 * add CRLF to response and flush to client
	 */
	response := func(line string) {
		data := line + "\r\n"
		for data != "" {
			client.conn.SetDeadline(time.Now().Add(gstmp_timeout))
			size, err := client.bufout.WriteString(data)
			if err != nil {
				panic(err)
			}
			client.bufout.Flush()
			data = data[size:]
		}
	}

	/*
	 * [todo] readUntil only works if suffix ends in '\n'
	 * [todo] limit length of string to be read during ReadString
	 */
	readUntil := func(suffix string) (string) {
		input := ""

		for ! strings.HasSuffix(input, suffix) {
			client.conn.SetDeadline(time.Now().Add(gstmp_timeout))
			reply, err := client.bufin.ReadString('\n')

			if err == nil && reply != "" {
				input = input + reply
				if len(input) > GSMTP_MAX_SIZE {
					err = errors.New("Maximum DATA size exceeded (" + strconv.Itoa(GSMTP_MAX_SIZE) + ")")
				}
			}

			if err != nil {
				panic(err)
			}
		}
		return input
	}

	readAndDecodeBase64 := func() (string) {
		input := readUntil("\r\n")
		trimmed := strings.Trim(input, " \n\r")
		return fromBase64(trimmed)
	}

	parseAuthPlain := func(auth_plain string) (username string, password string) {
		auth_plain = fromBase64(auth_plain)
		parts := strings.SplitN(auth_plain, "\x00", 3)
		return parts[1], parts[2]
	}

	authenticate := func(mode string, username string, password string) {
		if authenticateUser(username, password) {
			client.username = username
			client.log(warn, fmt.Sprintf("%s: authenticated from %s", mode, remote_addr))
			response("235 ok, go ahead")
		} else {
			client.log(fail, fmt.Sprintf("%s: %s failed for %s from %s", mode, GSTMP_AUTHENTICATE, username, remote_addr))
			response("530 NOT ALLOWED")
		}
	}

	const authenticated = 0
	const tls_off = 1
	const tls_on = 2 

	requires := func(args ...int) (bool) {
		for _, check := range args {
			switch {
				case check == authenticated && client.username == "":
					response("530 NOT ALLOWED"); return false
				case check == tls_off && client.tls_on:
					response("530 NOT ALLOWED, TLS is already enabled"); return false
				case check == tls_on && !client.tls_on && !GSMTP_TLS_OPTIONAL:
					response("530 NOT ALLOWED, must STARTTLS"); return false
			}
		}

		return true
	}

	const state_control = 1
	const state_data = 2 
	var STATE int 
	BEGIN := func(state int) { STATE = state }
	BEGIN(state_control)	// connection state

	client_errors := 0				// number of errors in this connection

	response(fmt.Sprintf("220 %s SMTP kinko.smtpd"))

	/* up to 99 commands in a single session. */
	for i := 0; i < 99; i++ {
		switch STATE {
		case state_control:
			input := readUntil("\r\n")
			input = strings.Trim(input, " \n\r")
			
			cmd, remainder := parseSmtpCommand(input)
			switch cmd {

			/*
			 * general commands
			 */
			default:
				client_errors++
				if client_errors > 3 {
					response("500 Too many unrecognized commands")
					return
				}
				response("500 unrecognized command")
			case HELO:
				client.helo = remainder
				response("250 "+ GSMTP_HOST_NAME +" Hello ")
			case EHLO:
				client.helo = remainder

				msg := "250-"+ GSMTP_HOST_NAME +" Hello "+client.helo+"["+remote_addr+"]"+"\r\n"
				msg += "250-SIZE "+ strconv.Itoa(GSMTP_MAX_SIZE) +"\r\n"
				if ! client.tls_on {
					msg += "250-STARTTLS\r\n"
				}
				msg += "250-AUTH PLAIN LOGIN\r\n"
				msg += "250 HELP "

				response(msg)
			case NOOP:
				response("250 OK")
			case RSET:
				client.mail_from = ""
				client.rcpt_to = ""
				response("250 OK")

			case QUIT:
				response("221 Bye")
				return

			/*
			 * upgrade to TLS
			 */
			case STARTTLS:
				if ! requires(tls_off) {
					break
				}

				response("220 Ready to start TLS")

				// upgrade to TLS
				tlsConn := tls.Server(client.conn, gstmp_tls_config)
				err := tlsConn.Handshake()
				if err != nil {
					err = errors.New(fmt.Sprintf("Could not TLS handshake:%v", err))
					panic(err)
				}

				client.conn = net.Conn(tlsConn)
				client.bufin = bufio.NewReader(client.conn)
				client.bufout = bufio.NewWriter(client.conn)
				client.tls_on = true
			
			/*
			 * authentication 
			 */
			case AUTH_PLAIN:
				if ! requires(tls_on) {
					break
				}

				username, password := parseAuthPlain(remainder)
				authenticate("PLAIN", username, password)
			case AUTH_LOGIN:
				if ! requires(tls_on) {
					break
				}

				response("334 VXNlcm5hbWU6")
				username := readAndDecodeBase64()

				response("334 UGFzc3dvcmQ6")
				password := readAndDecodeBase64()

				authenticate("LOGIN", username, password)

			/*
			 * email control
			 */ 
			case MAIL_FROM:
				if ! requires(tls_on, authenticated) {
					break
				}

				client.mail_from = remainder
				response("250 Ok")
			case RCPT_TO:
				if ! requires(tls_on, authenticated) {
					break
				}

				// [todo] allow multiple recipients
				client.rcpt_to = remainder
				response("250 Accepted")

			/*
			 * email data
			 */
			case DATA:
				if ! requires(tls_on, authenticated) {
					break
				}

				response("354 Enter message, ending with \".\" on a line by itself")
				BEGIN(state_data)
			}
		case state_data:
			client.data = readUntil("\r\n.\r\n")
			// [todo] add timeout handling.
			//
			// place the client on \a gstmp_save_mail_chan; one of 
			// the processMail workers will pick it up
			status := processMail(client)

			if status {
				response("250 OK: " + client.processMessage)
			} else {
				response("554 Error: " + client.processMessage)
			}
			BEGIN(state_control)
		}
	}
}

func authenticateUser(username string, password string) bool {
	cmd := exec.Command(GSTMP_AUTHENTICATE)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout

	os.Setenv("SSMTPD_USERNAME", username)
	os.Setenv("SSMTPD_PASSWORD", password)

	defer func() {
		os.Setenv("SSMTPD_USERNAME", "")
		os.Setenv("SSMTPD_PASSWORD", "")
	}()

	err := cmd.Run()
	return err == nil
}

func processMail(client *Client) (bool) {
		client.log(info, fmt.Sprintf("sent %d byte for %s from %s)", 
					len(client.data), 
					client.rcpt_to,
					client.mail_from))

		var err error

		if(GSTMP_PROCESS == "") {
			client.processMessage = fmt.Sprintf("received %d byte", len(client.data))
		} else {
			cmd := exec.Command(GSTMP_PROCESS, client.username)
			cmd.Stdin = strings.NewReader(client.data)
			cmd.Stderr = os.Stderr

			var out bytes.Buffer
			cmd.Stdout = &out
			err = cmd.Run()
			client.processMessage = firstLine(out)
			switch {
				case client.processMessage != "":
					;
				case err != nil:
					client.processMessage = "Unknown error"
				default:
					client.processMessage = "Success"
			}
		}

		if err != nil {
			client.log(fail, fmt.Sprintf("processing %d byte: %s/%s", 
					len(client.data),
					err, 
					client.processMessage))
		} else {
			client.log(warn, fmt.Sprintf("processed %d byte: %s", 
					len(client.data),
					client.processMessage))
		}

		return err == nil
}

func firstLine(buf bytes.Buffer) string {
	scanner := bufio.NewScanner(bytes.NewReader(buf.Bytes()))
	for scanner.Scan() {
		return scanner.Text()
	}
	
	return ""
}

func fromBase64(data string) string {
	buf := bytes.NewBufferString(data)
	decoder := base64.NewDecoder(base64.StdEncoding, buf)
	res, _ := ioutil.ReadAll(decoder)
	return string(res)
}

